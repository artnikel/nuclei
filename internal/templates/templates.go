package templates

import (
	"bytes"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"golang.org/x/net/html"
	"gopkg.in/yaml.v3"
)

type Request struct {
	Path []string `yaml:"path"`
}

type Template struct {
	ID       string                 `yaml:"id"`
	Info     map[string]interface{} `yaml:"info"`
	Requests []Request              `yaml:"requests"`
}

func (t *Template) MatchesURL(u *url.URL) bool {
	for _, req := range t.Requests {
		for _, p := range req.Path {
			cleanPath := strings.ReplaceAll(p, "{{BaseURL}}", "")

			if strings.HasSuffix(u.Path, cleanPath) || strings.HasPrefix(u.Path, cleanPath) {
				return true
			}
		}
	}
	return false
}

func FindMatchingTemplates(rawurl string, templatesDir string) ([]string, error) {
	u, err := url.Parse(rawurl)
	if err != nil {
		return nil, err
	}

	var matched []string

	err = filepath.Walk(templatesDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		if !strings.HasSuffix(info.Name(), ".yaml") && !strings.HasSuffix(info.Name(), ".yml") {
			return nil
		}

		data, err := os.ReadFile(path)
		if err != nil {
			return nil
		}

		var tpl Template
		err = yaml.Unmarshal(data, &tpl)
		if err != nil {
			return nil
		}

		if tpl.MatchesURL(u) {
			matched = append(matched, path)
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return matched, nil
}

func GenerateTemplate(targetURL string) string {
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Get(targetURL)
	if err != nil {
		return fmt.Sprintf("# Failed to request %s: %s\n", targetURL, err)
	}
	defer resp.Body.Close()

	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		parsedURL = &url.URL{}
	}

	baseURL := "{{BaseURL}}"

	serverHeader := resp.Header.Get("Server")
	contentType := resp.Header.Get("Content-Type")

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		bodyBytes = []byte{}
	}
	title := extractHTMLTitle(bytes.NewReader(bodyBytes))

	var buf bytes.Buffer
	buf.WriteString("id: autogenerated-template\n")
	buf.WriteString("info:\n")
	buf.WriteString("  name: Autogenerated Template\n")
	buf.WriteString("  author: scanner\n")
	buf.WriteString("  severity: info\n")
	buf.WriteString("  tags: autogenerated\n\n")

	buf.WriteString("requests:\n")
	buf.WriteString("  - method: GET\n")
	buf.WriteString("    path:\n")

	path := parsedURL.Path
	if path == "" {
		path = "/"
	}
	buf.WriteString(fmt.Sprintf("      - \"%s%s\"\n", baseURL, path))

	if parsedURL.RawQuery != "" {
		buf.WriteString(fmt.Sprintf("      - \"%s%s?%s\"\n", baseURL, path, parsedURL.RawQuery))
	}

	buf.WriteString("\n    matchers:\n")
	buf.WriteString(fmt.Sprintf("      - type: status\n        status:\n          - %d\n", resp.StatusCode))

	if serverHeader != "" {
		buf.WriteString("      - type: word\n        part: header\n        words:\n")
		buf.WriteString(fmt.Sprintf("          - \"%s\"\n", serverHeader))
	}
	if contentType != "" {
		buf.WriteString("      - type: word\n        part: header\n        words:\n")
		buf.WriteString(fmt.Sprintf("          - \"%s\"\n", contentType))
	}
	if title != "" {
		buf.WriteString("      - type: word\n        part: body\n        words:\n")
		buf.WriteString(fmt.Sprintf("          - \"%s\"\n", escapeYAMLString(title)))
	}

	return buf.String()
}

func extractHTMLTitle(r io.Reader) string {
	z := html.NewTokenizer(r)
	for {
		tt := z.Next()
		switch tt {
		case html.ErrorToken:
			return ""
		case html.StartTagToken:
			t := z.Token()
			if t.Data == "title" {
				tt = z.Next()
				if tt == html.TextToken {
					return strings.TrimSpace(string(z.Text()))
				}
			}
		}
	}
}

func escapeYAMLString(s string) string {
	if strings.ContainsAny(s, ":\n\"") {
		s = strings.ReplaceAll(s, "\"", "\\\"")
		return fmt.Sprintf("\"%s\"", s)
	}
	return s
}
