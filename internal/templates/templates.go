package templates

import (
	"bytes"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"golang.org/x/net/html"
	"gopkg.in/yaml.v3"
)

type Info struct {
	Name     string   `yaml:"name"`
	Author   string   `yaml:"author"`
	Severity string   `yaml:"severity"`
	Tags     []string `yaml:"tags,omitempty"`
}

type Matcher struct {
	Type   string   `yaml:"type"`            
	Part   string   `yaml:"part,omitempty"`   
	Words  []string `yaml:"words,omitempty"`  
	Status []int    `yaml:"status,omitempty"` 
	Regex  []string `yaml:"regex,omitempty"`  
	
}

type Request struct {
	Method   string            `yaml:"method,omitempty"`
	Path     []string          `yaml:"path"`
	Headers  map[string]string `yaml:"headers,omitempty"`
	Matchers []Matcher         `yaml:"matchers,omitempty"`
}

type Template struct {
	ID       string    `yaml:"id"`
	Info     Info      `yaml:"info"`
	Hosts    []string  `yaml:"hosts,omitempty"`
	Requests []Request `yaml:"requests"`
}

func (t *Template) MatchesURL(u *url.URL) bool {
	if len(t.Hosts) > 0 {
		matched := false
		for _, host := range t.Hosts {
			if strings.EqualFold(u.Hostname(), host) {
				matched = true
				break
			}
		}
		if !matched {
			return false
		}
	}

	baseURL := u.Scheme + "://" + u.Host
	fullURL := u.String()

	for _, req := range t.Requests {
		for _, p := range req.Path {
			candidate := strings.ReplaceAll(p, "{{BaseURL}}", baseURL)

			if strings.HasPrefix(fullURL, candidate) {
				return true
			}

			pathCandidate := candidate
			if strings.HasPrefix(candidate, baseURL) {
				pathCandidate = candidate[len(baseURL):]
			}
			if pathCandidate == "" {
				pathCandidate = "/"
			}
			urlPath := u.Path
			if urlPath == "" {
				urlPath = "/"
			}
			if urlPath == pathCandidate || strings.HasPrefix(urlPath, pathCandidate) {
				return true
			}
		}
	}
	return false
}

func FindMatchingTemplates(rawurl string, templatesDir string) ([]string, error) {
	u, err := url.Parse(rawurl)
	if err != nil {
		return nil, err
	}

	var matched []string

	err = filepath.Walk(templatesDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}
		if !strings.HasSuffix(info.Name(), ".yaml") && !strings.HasSuffix(info.Name(), ".yml") {
			return nil
		}

		data, err := os.ReadFile(path)
		if err != nil {
			return nil 
		}

		var tpl Template
		err = yaml.Unmarshal(data, &tpl)
		if err != nil {
			return nil 
		}

		if tpl.MatchesURL(u) {
			matched = append(matched, path)
		}
		return nil
	})

	if err != nil {
		return nil, err
	}
	return matched, nil
}

func GenerateTemplate(targetURL string) string {
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Get(targetURL)
	if err != nil {
		return fmt.Sprintf("# Failed to request %s: %s\n", targetURL, err)
	}
	defer resp.Body.Close()

	tpl, err := GenerateTemplateFromResponse(targetURL, resp)
	if err != nil {
		return fmt.Sprintf("# Failed to generate template from %s: %s\n", targetURL, err)
	}

	return tpl
}

func GenerateTemplateFromResponse(targetURL string, resp *http.Response) (string, error) {
	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		return "", err
	}

	baseURL := "{{BaseURL}}"
	path := parsedURL.Path
	if path == "" {
		path = "/"
	}

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		bodyBytes = []byte{}
	}
	title := extractHTMLTitle(bytes.NewReader(bodyBytes))

	serverHeader := resp.Header.Get("Server")
	contentType := resp.Header.Get("Content-Type")

	var buf bytes.Buffer
	buf.WriteString("id: autogenerated-template\n")
	buf.WriteString("info:\n")
	buf.WriteString("  name: Autogenerated Template\n")
	buf.WriteString("  author: scanner\n")
	buf.WriteString("  severity: info\n")
	buf.WriteString("  tags:\n")
	buf.WriteString("    - autogenerated\n\n")

	buf.WriteString("hosts:\n")
	buf.WriteString(fmt.Sprintf("  - %s\n\n", parsedURL.Hostname()))

	buf.WriteString("requests:\n")
	buf.WriteString("  - method: GET\n")
	buf.WriteString("    path:\n")
	buf.WriteString(fmt.Sprintf("      - \"%s%s\"\n", baseURL, path))

	if parsedURL.RawQuery != "" {
		buf.WriteString(fmt.Sprintf("      - \"%s%s?%s\"\n", baseURL, path, parsedURL.RawQuery))
	}

	buf.WriteString("\n    matchers:\n")
	buf.WriteString(fmt.Sprintf("      - type: status\n        status:\n          - %d\n", resp.StatusCode))

	if serverHeader != "" {
		buf.WriteString("      - type: word\n        part: header\n        words:\n")
		buf.WriteString(fmt.Sprintf("          - \"%s\"\n", escapeYAMLString(serverHeader)))
	}
	if contentType != "" {
		buf.WriteString("      - type: word\n        part: header\n        words:\n")
		buf.WriteString(fmt.Sprintf("          - \"%s\"\n", escapeYAMLString(contentType)))
	}
	if title != "" {
		buf.WriteString("      - type: word\n        part: body\n        words:\n")
		buf.WriteString(fmt.Sprintf("          - \"%s\"\n", escapeYAMLString(title)))
	}

	return buf.String(), nil
}

func extractHTMLTitle(r io.Reader) string {
	z := html.NewTokenizer(r)
	for {
		tt := z.Next()
		switch tt {
		case html.ErrorToken:
			return ""
		case html.StartTagToken:
			t := z.Token()
			if t.Data == "title" {
				if z.Next() == html.TextToken {
					return strings.TrimSpace(string(z.Text()))
				}
			}
		}
	}
}

func escapeYAMLString(s string) string {
	if strings.ContainsAny(s, ":\n\"") {
		s = strings.ReplaceAll(s, "\"", "\\\"")
		return fmt.Sprintf("\"%s\"", s)
	}
	return s
}

func FindFirstTemplate(url, dir string) (*Template, error) {
	matches, err := FindMatchingTemplates(url, dir)
	if err != nil {
		return nil, err
	}
	if len(matches) == 0 {
		return nil, fmt.Errorf("no matching template found")
	}

	data, err := os.ReadFile(matches[0])
	if err != nil {
		return nil, fmt.Errorf("failed to read template: %w", err)
	}

	var tmpl Template
	if err := yaml.Unmarshal(data, &tmpl); err != nil {
		return nil, fmt.Errorf("failed to parse template: %w", err)
	}

	return &tmpl, nil
}

