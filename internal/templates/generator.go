package templates

import (
	"bytes"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"golang.org/x/net/html"
)

func GenerateTemplate(targetURL string) string {
	client := newInsecureHTTPClient(10 * time.Second)
	resp, err := client.Get(targetURL)
	if err != nil {
		return fmt.Sprintf("# Failed to request %s: %s\n", targetURL, err)
	}
	defer resp.Body.Close()

	tpl, err := GenerateTemplateFromResponse(targetURL, resp)
	if err != nil {
		return fmt.Sprintf("# Failed to generate template from %s: %s\n", targetURL, err)
	}

	return tpl
}

func GenerateTemplateFromResponse(targetURL string, resp *http.Response) (string, error) {
	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		return "", err
	}

	baseURL := "{{BaseURL}}"
	path := parsedURL.Path
	if path == "" {
		path = "/"
	}

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		bodyBytes = []byte{}
	}
	title := extractHTMLTitle(bytes.NewReader(bodyBytes))

	serverHeader := resp.Header.Get("Server")
	contentType := resp.Header.Get("Content-Type")

	var buf bytes.Buffer
	buf.WriteString("id: autogenerated-template\n")
	buf.WriteString("info:\n")
	buf.WriteString("  name: Autogenerated Template\n")
	buf.WriteString("  author: scanner\n")
	buf.WriteString("  severity: info\n")
	buf.WriteString("  tags:\n")
	buf.WriteString("    - autogenerated\n\n")

	buf.WriteString("hosts:\n")
	buf.WriteString(fmt.Sprintf("  - %s\n\n", parsedURL.Hostname()))

	buf.WriteString("requests:\n")
	buf.WriteString("  - method: GET\n")
	buf.WriteString("    path:\n")
	buf.WriteString(fmt.Sprintf("      - \"%s%s\"\n", baseURL, path))
	if parsedURL.RawQuery != "" {
		buf.WriteString(fmt.Sprintf("      - \"%s%s?%s\"\n", baseURL, path, parsedURL.RawQuery))
	}

	buf.WriteString("\n    matchers:\n")
	buf.WriteString(fmt.Sprintf("      - type: status\n        status:\n          - %d\n", resp.StatusCode))

	if serverHeader != "" {
		buf.WriteString("      - type: word\n        part: header\n        words:\n")
		buf.WriteString(fmt.Sprintf("          - \"%s\"\n", escapeYAMLString(serverHeader)))
	}
	if contentType != "" {
		buf.WriteString("      - type: word\n        part: header\n        words:\n")
		buf.WriteString(fmt.Sprintf("          - \"%s\"\n", escapeYAMLString(contentType)))
	}
	if title != "" {
		buf.WriteString("      - type: word\n        part: body\n        words:\n")
		buf.WriteString(fmt.Sprintf("          - \"%s\"\n", escapeYAMLString(title)))
	}

	return buf.String(), nil
}

func extractHTMLTitle(r io.Reader) string {
	doc, err := html.Parse(r)
	if err != nil {
		return ""
	}

	var title string
	var f func(*html.Node)
	f = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == "title" && n.FirstChild != nil {
			title = n.FirstChild.Data
			return
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(doc)
	return title
}

func escapeYAMLString(s string) string {
	s = strings.ReplaceAll(s, "\"", "\\\"")
	return s
}
